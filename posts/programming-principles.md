# 编程最高准则转自[http://webpro.github.io/programming-principles/](http://webpro.github.io/programming-principles/)每一个编程人员都可以从编程最高准则中得到好处。这里列出的是我自己总结出来的一些准则，基本上所有的编程都会围绕这些准则进行，在学习各种设计模式之前，了解这里的所有准则也是非常必要的，因为设计模式也是符合这些准则的。请注意这个列表远远还没有最终完成，你可能也经常需要在不同又冲突的准则之间进行取舍。这个列表灵感来源于[编程的艺术](http://www.artima.com/weblogs/viewpost.jsp?thread=331531)。我觉得这个清单非常不错，我在这个清单的基础上增加了一些细节，希望各位读者读后能有所收获。## 目录### 普通准则* [KISS (Keep it simple stupid)](#kiss)* [YAGNI (You aren't gonna need it)](#yagni)* [Do The Simple Thing That Could Possibly Work](#dothesimple)  * [Keep Things DRY](#keep-things-dry)  * [SOLID准则](#solid)<div id="kiss"></div>## KISS绝大多数工作良好的系统都是简单的设计，而不是复杂的设计。理由：* 更少的代码意味着花费更少的时间便可以编写，bug更少，且更易修改* 最终极的复杂反而是简单* 完美的定义就是什么也不需要增加了，同时什么也都没法再少<div id="yagni"></div>## YAGNIYAGIN来自于“You aren't gonna need it”的缩写，意思是：不要去实现你不需要的东西。理由：* 完成任何明天才需要的功能开发任务，都会消耗完成当前任务的精力* 完成不需要的东西导致代码变得臃肿和复杂<div id="dothesimple"></div>## Do The Simple Thing That Could Possibly Work理由：* 当我们专注在实际问题的领域内时，工作是最有效率的怎样做：* 做事情之前，先问自己：“这个东西最简单的实现方式是什么？”<div id="keep-things-dry"></div>## Keep things DRY每一个细小的编程模块，在整个系统中都必须是唯一的，没有歧义的，并且是权威的。重要的功能模块在程序里面应该只有一处实现。如果类似的代码在许多地方都出现，一般来说需要考虑是否应该将它们抽象和合并起来。理由：* 重复代码可能导致维护的噩梦，降低系统的可重构性，并可能引发逻辑矛盾* 所有代码使用同样的编程模块，这样只修改这一处便可以达到全部相关代码逻辑都更新的效果* 可以保持所有逻辑相关代码的一致性怎样做：* 业务规则，表达式，if判断，数学公式，元数据，等等。只保留在一处* 分辨和找出所有系统里面共同的逻辑，将它们抽取出来* 应用“三处法则”，则当一个实现出现第三次时，就开始将它抽象出来<div id="solid"></div>## SOLID准则S.O.L.I.D是面向对象设计和编程中几个重要编码原则的首字母缩写<table>    <tr>        <td>SRP</td>        <td>The Single Responsibility Principle</td>        <td>单一责任原则</td>    </tr>    <tr>        <td>OCP</td>        <td>The Open Closed Principle</td>        <td>开放封闭原则</td>    </tr>    <tr>        <td>LSP</td>        <td>The Liskov Substitution Principle</td>        <td>里氏替换原则</td>    </tr>    <tr>        <td>DIP</td>        <td>The Dependency Inversion Principle</td>        <td>依赖倒置原则</td>    </tr>    <tr>        <td>ISP</td>        <td>The Interface Segrregation Principle</td>        <td>接口分离原则</td>    </tr></table>### 单一责任原则某个类应该只完成一个独立的事情，当一个类需要负责完成很多不同的逻辑时，考虑分拆这个类。例子：瑞士军刀Just because you can, doesn't mean you should.### 开放封闭原则软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。### 里氏替换原则 当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系### 依赖倒置原则* 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 * 抽象不应该依赖于细节，细节应该依赖于抽象 ### 接口分离原则不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。