<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="javajavadog&#39;s blog : recording my life">

    <link rel="stylesheet" type="text/css" media="screen" href="../stylesheets/stylesheet.css">

    <title>blog.imwmw.com</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">

          <h1 id="project_title">blog.imwmw.com</h1>
          <h2 id="project_tagline">recording my life</h2>

        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">

<h1>编程最高准则</h1>

<p>转自<a href="http://webpro.github.io/programming-principles/">http://webpro.github.io/programming-principles/</a></p>

<p>每一个编程人员都可以从编程最高准则中得到好处。这里列出的是我自己总结出来的一些准则，基本上所有的编程都会围绕这些准则进行，在学习各种设计模式之前，了解这里的所有准则也是非常必要的，因为设计模式也是符合这些准则的。请注意这个列表远远还没有最终完成，你可能也经常需要在不同又冲突的准则之间进行取舍。</p>

<p>这个列表灵感来源于<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=331531">编程的艺术</a>。我觉得这个清单非常不错，我在这个清单的基础上增加了一些细节，希望各位读者读后能有所收获。</p>

<h2>目录</h2>

<h3>普通准则</h3>

<ul>
<li><a href="#kiss">KISS (Keep it simple stupid)</a></li>
<li><a href="#yagni">YAGNI (You aren't gonna need it)</a></li>
<li><a href="#dothesimple">Do The Simple Thing That Could Possibly Work</a>  </li>
<li><a href="#keep-things-dry">Keep Things DRY</a>  </li>
<li><a href="#solid">SOLID准则</a></li>
</ul>

<div id="kiss"></div>

<h2>KISS</h2>

<p>绝大多数工作良好的系统都是简单的设计，而不是复杂的设计。</p>

<p>理由：</p>

<ul>
<li>更少的代码意味着花费更少的时间便可以编写，bug更少，且更易修改</li>
<li>最终极的复杂反而是简单</li>
<li>完美的定义就是什么也不需要增加了，同时什么也都没法再少</li>
</ul>

<div id="yagni"></div>

<h2>YAGNI</h2>

<p>YAGIN来自于“You aren't gonna need it”的缩写，意思是：不要去实现你不需要的东西。</p>

<p>理由：</p>

<ul>
<li>完成任何明天才需要的功能开发任务，都会消耗完成当前任务的精力</li>
<li>完成不需要的东西导致代码变得臃肿和复杂</li>
</ul>

<div id="dothesimple"></div>

<h2>Do The Simple Thing That Could Possibly Work</h2>

<p>理由：
* 当我们专注在实际问题的领域内时，工作是最有效率的</p>

<p>怎样做：
* 做事情之前，先问自己：“这个东西最简单的实现方式是什么？”</p>

<div id="keep-things-dry"></div>

<h2>Keep things DRY</h2>

<p>每一个细小的编程模块，在整个系统中都必须是唯一的，没有歧义的，并且是权威的。</p>

<p>重要的功能模块在程序里面应该只有一处实现。如果类似的代码在许多地方都出现，一般来说需要考虑是否应该将它们抽象和合并起来。</p>

<p>理由：
* 重复代码可能导致维护的噩梦，降低系统的可重构性，并可能引发逻辑矛盾
* 所有代码使用同样的编程模块，这样只修改这一处便可以达到全部相关代码逻辑都更新的效果
* 可以保持所有逻辑相关代码的一致性</p>

<p>怎样做：
* 业务规则，表达式，if判断，数学公式，元数据，等等。只保留在一处
* 分辨和找出所有系统里面共同的逻辑，将它们抽取出来
* 应用“三处法则”，则当一个实现出现第三次时，就开始将它抽象出来</p>

<div id="solid"></div>

<h2>SOLID准则</h2>

<p>S.O.L.I.D是面向对象设计和编程中几个重要编码原则的首字母缩写</p>

<table>
    <tr>
        <td>SRP</td>
        <td>The Single Responsibility Principle</td>
        <td>单一责任原则</td>
    </tr>
    <tr>
        <td>OCP</td>
        <td>The Open Closed Principle</td>
        <td>开放封闭原则</td>
    </tr>
    <tr>
        <td>LSP</td>
        <td>The Liskov Substitution Principle</td>
        <td>里氏替换原则</td>
    </tr>
    <tr>
        <td>DIP</td>
        <td>The Dependency Inversion Principle</td>
        <td>依赖倒置原则</td>
    </tr>
    <tr>
        <td>ISP</td>
        <td>The Interface Segrregation Principle</td>
        <td>接口分离原则</td>
    </tr>
</table>

<h3>单一责任原则</h3>

<p>某个类应该只完成一个独立的事情，当一个类需要负责完成很多不同的逻辑时，考虑分拆这个类。</p>

<p>例子：瑞士军刀
Just because you can, doesn't mean you should.</p>

<h3>开放封闭原则</h3>

<p>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。</p>

<h3>里氏替换原则</h3>

<p>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系</p>

<h3>依赖倒置原则</h3>

<ul>
<li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象 </li>
<li>抽象不应该依赖于细节，细节应该依赖于抽象 </li>
</ul>

<h3>接口分离原则</h3>

<p>不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。</p>

	</section></div>
    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p><a href="http://blog.imwmw.com">http://blog.imwmw.com</a> &copy; 2015 Xiang Li</p>
      </footer>
    </div>

    

  </body>
</html>

